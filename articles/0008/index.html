<div class="article">
<h1>Software Release Management Best Practices</h1>
<p id="articlehead">This article describes the fundamental concepts of
software release management, the types of releases and their lifecycles,
and then discusses 10 best practices that can be adopted to improve your
own software release management process.</p>
<h2>Introduction</h2>
<p>The development of software applications is an evolutionary
process, moving towards some predetermined end goals. These goals are
usually in the form of a release, either internal or external, to
deliver a set of required functionality. Software Release Management is
the process of ensuring that these releases can be reliably constructed,
their content controlled and the outputs transitioned (deployed) to test
or run-time environments. It is often a manual and laborious process and
consequently sometimes error prone.</p>
<p>The term Release Management can mean different things to
different people. Therefore, this article deliberately uses the term <i>Software
Release Management </i>to mean the release of software (and immediately
related artefacts) as part of the software development lifecycle. This
is distinct from what could be called <i>Implementation Release
Management</i>, which moves out of the software development arena and into
service delivery, whereby all aspects of hardware installation (e.g. do
we need new PCs?), infrastructure upgrade (e.g. do we need to upgrade
inter-site links?) and end-user training are considered. In some cases
such a release might not include any software artefacts at all.</p>
<p>In reality, software release management is part of <i>Software
Configuration Management</i>, but again this term often has different
meanings, so for the sake of sanity and to establish a framework for the
rest of this article, we will use the following definitions:</p>
<ul>
	<li><i>Software Configuration Management</i><br />
	Secure storage, version control, baselining and workspace management of
	all artefacts.</li>
	<li><i>Software Change Management</i><br />
	Activity Management and tracking of software problems, defects and
	change requests.</li>
	<li><i>Software Release Management</i><br />
	Build, construction and packaging into Deployment Unit(s) of software
	versions. In software development this is often called <span
		style="font-style: italic;">Release Engineering</span>.<br />
	</li>
	<li><i>Deployment (or Distribution)</i><br />
	Physical transition of the Deployment Unit.</li>
</ul>
<p>You will have noticed that we have introduced another term here,
the <i>Deployment Unit</i>. This is one of the fundamental concepts of
software release management. At the end of the day, what we are trying
to produce is a self-contained installable, documented and traceable
release of software. This is the Deployment Unit. It is not necessarily
a single artefact like a J2EE .EAR file, but rather a collection of
related artefacts. This is illustrated in the following diagram.</p>
<div align="center"><img width="468" height="262" border="0"
	src="%image_dir%/deployment-unit.jpg" alt="" /></div>
<p>Essentially, what this diagram is saying is that code (Work
Product Components) is built (into Deployment Components) and packaged
up (into a Build Release). It is the Build Release (like the J2EE .EAR
file) that is deployed, but without the rest of the supporting artefacts
that make up the Deployment Unit (the installation instructions,
run-time configuration files etc.) it is in effect meaningless.</p>
<h2>Types of Release</h2>
<p>There are a number of different types of software release that
can be made, depending on whether all the build components of the
release are to be included or not. For example, a release can be said to
be any one of the following:</p>
<ul>
	<li><i>Full Release </i><br />
	A full release includes the full set of build components, usually as
	the result of a complete re-compilation.</li>
	<li><i>Partial (delta) Release</i><br />
	A partial release only includes the build components that have been
	changed, i.e. the database drivers.</li>
	<li><i>Patch</i><br />
	A patch only includes a subset of a build component that has been
	changed, i.e. the Windows ODBC library from the database drivers.</li>
	<li><i>Maintenance or Service Release</i><br />
	A maintenance release is usually a full release plus a number of
	partial releases and/or patches. A maintenance release is usually
	carried out to create a stable baseline release for customers, when
	there have been a number of patches introduced. Potentially these
	patches could have been <i>hot-fixes</i> delivered only to specific
	customers. The maintenance release mechanism is a way of making these
	hot-fixes available to all the customers.</li>
	<li><i>Package Release</i><br />
	A package release is a collection of a number of software releases
	packaged up to ease the deployment process. It could be a number of
	patches packaged to together or even a number of loosely related
	applications.</li>
</ul>
<p>There are a number of criteria for identifying which type of
release mechanism an organisation should select. Where releases are
deployed internally and there is usually only one version of an
application running, i.e. Financial Services, then it is probably easy
to carry out a full release each time. Where releases are deployed
externally and there can be many versions of an application running,
i.e. Software Tool Vendors, then a combination of full releases, patches
and maintenance (or service) releases is usually required.</p>
<h2>Example Release Lifecycle</h2>
<p>An example of a release lifecycle that I have experienced first
hand, was for a Network Management applications suite. This suite
basically consisted of a number of related projects delivering into a
central build function in order to make a release. There were upwards of
10 projects located around the world. The releases were made to a small
number of large external customers, however there was the potential for
each of the customers to be running different releases. The timeline of
releases for this suite looked something like this:</p>
<ul>
	<li>Jan 01 - Release 1.0 (<i>Full Release</i>)</li>
	<li>Feb 01 - 3 Patches (<i>Packaged</i>)</li>
	<li>Mar 01 - 2 Patches (<i>Packaged</i>)</li>
	<li>Apr 01 - Release 1.1 (<i>Maintenance</i> &ndash; Release 1.0 +
	7 Patches)</li>
	<li>&hellip;</li>
	<li>Jan 02 - Release 2.0 (<i>Full Release</i>)</li>
	<li>...</li>
</ul>
<p>The frequency of releases for this suite was as follows:</p>
<ul>
	<li>Yearly Major Release Cycle</li>
	<li>Quarterly Minor Maintenance Release (or when complexity
	dictated)</li>
	<li>Patches on an ongoing basis</li>
</ul>
<p>There was also the potential for a number of releases to be
underway at the same time, i.e. maintenance releases of release 1 whilst
release 2 was being deployed.</p>
<h2>Best Practices</h2>
<p>The definition and examples of releases that we have discussed
above, together with many years experience observing the software
release process, has led me to recommend the following 10 best practices
for Software Release Management - you always need 10 best practices! The
best practices (in no particular order) are as follows:</p>
<p><b>1. Have regular, targeted Release dates</b><br/>
You should rigorously plan and manage your releases and deliver
releases regularly. Construct a release plan to indicate both the major
(full) and minor (maintenance) release dates milestones. If a number of
releases are being developed in parallel, these should be indicated on a
single plan. Also, internal releases should be made and planned in the
same manner; even if the final release is not intended to ship to
customers for 18 months, you should still have internal releases along
the way, i.e. every 3 months to prove the release process.</p>
<p><b>2. Always have a tested back-out plan</b><br/>
For releases that are being deployed to managed live
environments, i.e. an Internet Banking system, you should always have a
tested back-out plan. For example, if you deploy a new Internet Banking
release onto the production servers and subsequently find that there are
problems with it, there should be a process in place for removing this
release and rolling back to the previous one. In this scenario it is
desirable that this process is as automatic as possible.</p>
<p><b>3. Have a documented Software Release Management process,
describing roles, activities and artefacts</b><br/>
Your software release management process should be defined and
documented. Usually this type of information is captured in a <a
	href="http://www.buildmeister.com/modules/content/index.php?id=16">Software
Configuration Management Plan</a>. Make sure that this plan clearly states
who is responsible for each part of the release process, i.e. who plans
and manages the release, who builds and delivers the release internally
and who packages and deploys the release externally. All the artefacts
that are to be produced as part of the release process, i.e. Release
Plan, Release Notes, Installation Instructions, should be clearly
documented (and example templates given) along with who is responsible
for generating them.</p>
<p><b>4. Construct Deployment Units as early as possible</b><br/>
Every time you build your application you should be constructing
deployment units with the potential to be installed, for example a J2EE
.EAR file or a Windows .MSI package. Such builds might not be released
beyond the development team but the point is that the build and
packaging process is proven early and at each phase.</p>
<p><b>5. Use an independent team to construct all external Releases</b><br />
If your team is very small then the developers might be able to
carry out the build and construct the deployment unit. However, for any
medium to large size project it is desirable to have a separate release
team. This team usually manages the build process and packages up the
results of the build into the deployment unit. They usually deploy
internally (and sometimes externally) or pass the deployment unit to a
separate deployment team.</p>
<p><b>6. All Deployments should be performed by a team independent of
the Development team</b><br/>
Developers should not be allowed to transition deployment units
into a live environment. There is a potential conflict of interests in
this situation. For auditability and traceability it is better to have a
separate team deploy the release.</p>
<p><b>7. Test the Deployment process at least once before deploying
to Live</b><br/>
The deployment process should be tested at least once before any
release is put into a live environment. This is normally carried out by
having an Acceptance Test environment that mimics the live environment
and is controlled in the same way.</p>
<p><b>8. Automate as much as possible &ndash; use integrated tools
for Configuration, Change Request Management and Deployment</b><br/>
Software release management can be a repetitive and error prone
manual process. As much as possible should be automated. At the very
least, the inputs and outputs of the release process (including the
build components and release documentation) should be version controlled
using a tool. A change request management tool can be used for
controlling the content of the release and making requests for changes
to it. A deployment tool can be used to move the release to different
environments or to install onto multiple desktop machines. Obviously,
this all works best if these tools are integrated to some degree.</p>
<p><b>9. Use a mature Software Configuration Management process and
tool to support the development of multiple releases in parallel</b><br/>
When you are developing, building and deploying
multiple releases in parallel it is critical that you have a version
management tool that supports parallel development. Such tools are
usually high-end, expensive toolsets (not open-source equivalents)
but can save and automate the otherwise manual branching and merging
process significantly.</p>
<p><b>10. Include all Release documentation and scripts with your
Deployment Unit</b><br />
When a release is deployed you should be able to identify from
the Deployment Unit all the related hardware and software that is
required to support the release. The deployment unit can either relate
all this together in documentation form or better still reference
entries in a database. Such a database should identify for each software
application this is built and released: the required hardware,
supporting third-party software and the Installation and Configuration
instructions. In the <a href="http://www.itil.co.uk">ITIL</a> world such
a database is often called the CMDB (Configuration Management Database).</p>
</div>