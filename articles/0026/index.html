<div id="article">
<h1>Defining Agile Software Delivery</h1>
<p id="articlehead">This article describes the concept of Agile
Software Delivery and how it can be applied.</p>
<h2>Software Delivery and ALM</h2>
<p>When most people talk about the build process, they typically
focus on a very narrow definition – usually thinking in terms of code,
of compilation, and of the technical implementation of build tools.
These are some of the aspects of a build process but certainly they are
not the only ones. Build processes are also not defined in isolation,
they are typically part of complete Application Lifecycle Management
(ALM) solution - one that is hopefully implemented to ensure the
successful delivery of software applications. Given this it is entirely
possible and reasonable to therefore talk about the build process as
enabling <b>software delivery</b> - ensuring that software is delivered
to its end users, in as timely and efficient way as possible.</p>
<p>By definition, software delivery is a mechanistic foundation. It
is not a process or method in its own right, rather it is a collection
of automated functions to underpin ALM and help bridge the delivery gap
that exists between development teams, operations and the applications
ultimate end users. By using this definition, it is hopefully clearer
that the build process is not about building for building’s sake – a
build has no value in isolation – rather it is about helping to add
value to a project – incrementally, over time, and throughout its entire
lifecycle.</p>
<h2>The Build Process and Agility</h2>
<p>Following this definition, it should be no surprise that the
overall process of software delivery should be as agile as possible.
This is not agile as in the sense of Agile Development practices; rather
it is the need for agility in processes that can potentially be executed
many times over and that need to share and publish relevant information
as a continuous pipeline. The diagram below illustrates the pipeline
concept of <b>Agile Software Delivery</b> - with frequent and repeatable builds
and deployments.</p>
<p style="text-align: center;"><img alt="[Agile Software Delivery]"
	src="%image_dir%/AgileSoftwareDelivery.gif" /></p>
<p>It illustrates that shared infrastructure and the
outputs of previous (related) builds can be used as inputs to the
software delivery process. The idea behind this is the more that can be shared the more
likely it is possible to decrease the total build time and to ensure
consistency.</p>
<p>The diagram also illustrates that the outputs of the software
delivery process are the build outputs and builds reports, which are
made available so that content can be potentially shared by other
processes.</p>
<h2>Enabling Agile Software Delivery</h2>
<p>In order to implement a build process to enable Agile Software
Delivery I believe there are three key enablers:</p>
<ul>
	<li>Automation – of manual and repetitive tasks in as quick and
	timely a way of possible.</li>
	<li>Communication – of build success or failure as well as reports
	and metrics on build content, trends and quality.</li>
	<li>Re-use – of build tools, technology and infrastructure across
	project and organizational boundaries.</li>
</ul>
<p>Enablers such as these are often easy to state but hard to
implement. In the course of this book I will therefore describe them in
more detail as well as discuss strategies on how they can be
successfully implemented. Hopefully by doing so, you will then be able
to achieve Agile Software Delivery in your own environment.</p>
</div>