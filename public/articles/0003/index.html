<div id="article">
<h1>Introduction to Test Driven Development and JUnit</h1>
<p id="articlehead">This article describes the principles of Test
Driven Development and the Java unit testing framework tool JUnit that
can be used to implement it.</p>
<h2>Introduction</h2>
<p>Test Driven Development (TDD) is a popular programming practice
used by developers to attain high-levels of quality in their
code.&nbsp;The TDD method consists principally of planning and writing
unit tests <span style="font-weight: bold;">first. </span>For the
implementation of some new piece of functionality, TDD can simply be
stated as follows:</p>
<ul>
	<li>you write a test class, compile and execute it</li>
	<li style="font-style: italic;">the test class fails</li>
	<li>you write the implementation class (e.g. a Java class),
	compile and execute it just enough to make the test class pass</li>
	<li style="font-style: italic;">you refactor the implementation
	class as necessary</li>
</ul>
<p>As an example, suppose you were creating a new Java class to
model a customer&rsquo;s bank account and that the account would
ultimately hold data and have methods to access this data as follows:</p>
<pre name="code" class="Java">
// private data
private String id;          // account identifier
private String type;        // account type
private BigDecimal balance; // account balance

// public methods
public Account();
public Account(String accountid); 
public String getId(); 
public String getType(); 
public BigDecimal getBalance(); 
public void setId(String id); 
public void setType(String type); 
public void setBalance(BigDecimal balance); 
public BigDecimal deposit(BigDecimal amount); 
public BigDecimal withdraw(BigDecimal amount);
</pre>
<p>Before you even wrote the code for this class, it would be good
practice to work out how it would be exercised, identifying the
successful and unsuccessful boundary and error conditions. For example:</p>
<ul>
	<li>what would happen if I requested information on an account
	that did not exist?</li>
	<li>what would happen if I set the account balance to both
	positive and negative values?</li>
	<li>what would happen if I tried to withdraw more cash than the
	account currently held?</li>
</ul>
<p>These conditions can be coded using a unit testing framework like
<a href="http://www.junit.org/">JUnit</a> (for Java code) using what are
called <span style="font-weight: bold;">assertions</span>. To implement
TDD, you would therefore write a JUnit test class to instantiate the
account class and exercise its (as yet unimplemented) methods. At
certain points in the code you assert what should happen, based on the
input you provide. &nbsp;As an example, the starting point for the JUnit
test class (in this case called <span style="font-weight: bold;">TestAccount.java</span>)
would look something like this:</p>
<pre name="code" class="java">
public class TestAccount extends TestCase {

    private Account a1;

    public TestAccount(String arg0) {
        super(arg0);
    } 
 
    protected void setUp() { 
        a1 = new Account(&quot;101-1001&quot;); 
        a1.setType(&quot;Current&quot;); 
        a1.setBalance(new BigDecimal(&quot;100.25&quot;)); 
    }
 
    public void testGetters() { 
        assertTrue(!a1.equals(null));  
        BigDecimal balance = new BigDecimal(&quot;100.25&quot;); 
        assertEquals(a1.getId(), &quot;101-1001&quot;); 
        assertEquals(a1.getType(), &quot;Current&quot;); 
        assertEquals(a1.getBalance(), balance); 
        a1.setId(&quot;101-1002&quot;); 
        assertEquals(a1.getId(), &quot;101-1002&quot;); 
    } 
 
    public void testDeposit() {< 
        BigDecimal balance = new BigDecimal(&quot;150.50&quot;); 
        assertEquals(a1.deposit(new BigDecimal(&quot;50.25&quot;)), balance);
    }

    public void testWithdraw() { 
        BigDecimal balance = new BigDecimal(&quot;70.01&quot;); 
        try { 
            assertEquals(a1.withdraw(new BigDecimal(&quot;30.24&quot;)), balance); 
        } catch (InsufficientFundsException ex) { 
            ex.printStackTrace(); 
        } 
        try { 
            // withdraw too much 
            a1.withdraw(new BigDecimal(&quot;10000.00&quot;)); 
            fail(&quot;withdraw hasn't caused an exception when it should&quot;); 
        } 
        catch (InsufficientFundsException ex) { } 
    }
 
} 
</pre>
<p>This JUnit test class has a number of test cases identified by
each method that starts with the word <span style="font-weight: bold;">test</span>
(for example<span style="font-weight: bold;"> testDeposit</span>), it
also has an additional method called <span style="font-weight: bold;">setUp</span>
which JUnit invokes before each method to ensure a stable test
environment (it is also possible to specify a <span
	style="font-weight: bold;">tearDown</span> method to cleanup an
environment). Of particular interest is the <span
	style="font-weight: bold;">testWithdraw</span> method which implements
a test to withdraw more than the account contains (on lines 37 to 40).
In this scenario we want to make sure that the <span
	style="font-weight: bold;">InsufficientFundsException</span> is called,
if not we have an error in our code and the JUnit <span
	style="font-weight: bold;">fail</span> method is used to fail the test
case.</p>
<p>Obviously compiling and executing this test class
on its own, without the implementation class would fail, so next an
implementation class (in this case called <span
	style="font-weight: bold;">Account.java)</span> would be developed to
make these test cases pass as follows:</p>
<pre name="code" class="java">
public class Account implements Comparable, Serializable { 
 
    // The account business data 
    private String id; 
    private String type; 
    private BigDecimal balance; 
 
    public Account() { super(); }
 
    public Account(String accountid) { 
        setId(accountid); 
        setBalance( new BigDecimal(0.00)); 
    } 
 
    // getters 
    public String getId() { return id; } 
    public String getType() { return type; } 
    public java.math.BigDecimal getBalance() { return balance; } 
 
    // setters 
    public void setId(String id) { this.id = id; }
    public void setType(String type) { this.type = type; }
    public void setBalance(java.math.BigDecimal balance) { this.balance = balance; } 
 
    // business methods
    public BigDecimal deposit(BigDecimal amount) { 
        setBalance(getBalance().add(amount)); 
        return getBalance();
    } 
 
    public BigDecimal withdraw(BigDecimal amount) throws InsufficientFundsException { 
        if (getBalance().compareTo(amount) == -1)  
            throw new InsufficientFundsException(&quot;Insufficient funds for withdrawal&quot;); 
        setBalance(getBalance().subtract(amount) );
        return getBalance(); 
    } 
 
}
</pre>
<p>Over time you would obviously be asked to add new methods, in
which case again you would update the test class first, it would fail
and you would then write the implementation class. Also over time you
might need to refactor the implementation class, maybe because you want
to make the code more readable or need to optimize it for performance.
In lots of teams, developers are often afraid of optimization
because they have brittle code and it might introduce errors. However
with TDD you always have the test classes - these can be executed to
check that you have not violated the interface or introduced any
unnecessary side affect.</p>
<p>Test Driven Driven can prove very effective during defect fixing.
For example, if a new defect has been found, as a developer your first
step should be to ascertain whether you can write a unit test to expose
the defect. Although this might not always be possible, if it is, then
you now have the opportunity to embed it in your unit test suite and
ensure that this type of defect does not appears again.</p>
<p>In practice Test Driven Development is often combined with <a
	href="http://www.buildmeister.com/modules/content/index.php?id=22">Continuous
Integration</a> and can be very powerful and effective way of incrementally
delivering software in dynamic environments. There are many&nbsp;tools
that can be used to support TDD other than JUnit, most of which are in
the<span style="font-style: italic;"> nUnit</span> family. For example <a
	href="http://httpunit.sourceforge.net/">HTTPUnit</a> can execute
functional tests on a set of web pages using the HTTP protocol, whilst <a
	href="http://sqlunit.sourceforge.net/">SQLUnit</a> can execute tests on
database stored procedures. Where applications need to be executed in
some form of runtime container (e.g.&nbsp;Enterprise Java Beans) then
additional tools are often used to support TDD. For example mock objects
can be created that run outside of the container using tools like <a
	href="http://www.mockejb.org/">mockEJB</a> or the application can be
deployed into the container and tools like <a
	href="http://jakarta.apache.org/cactus/">Cactus</a> used to execute
them in a more &quot;integration&quot; like environment.</p>
<p>For more background information on Test Driven Development see <a
	href="http://www.amazon.com/Test-Driven-Development-Addison-Wesley-Signature/dp/0321146530">Kent
Beck's book</a>. For more detail on how to construct JUnit tests and test
suites see the <a
	href="http://www.amazon.com/Pragmatic-Unit-Testing-Java-JUnit/dp/0974514012">book
by Andy Hunt and Dave Thomas</a>.</p>
</div>